using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

using PlagueEngine.LowLevelGameFlow;

/************************************************************************************/
/// PlagueEngine.Rendering.Components
/************************************************************************************/
namespace PlagueEngine.Rendering.Components
{

    /********************************************************************************/
    /// Camera Component
    /********************************************************************************/
    class CameraComponent : GameObjectComponent
    {

        /****************************************************************************/
        /// Fields
        /****************************************************************************/
        private Matrix   projection = Matrix.Identity;
        private float    fov        = 0;
        private float    aspect     = 0;        
        private float    zNear      = 0;
        private float    zFar       = 0;

        private Renderer    renderer   = null;
        private Quaternion  quaternion;
        private BoundingFrustum frustrum;
        /****************************************************************************/



        /****************************************************************************/
        /// Constructor
        /****************************************************************************/
        public CameraComponent( GameObjectInstance gameObject,
                                Renderer renderer,
                                float fov,
                                float zNear,
                                float zFar) : base(gameObject)
        {
            this.renderer   = renderer;
            this.fov        = MathHelper.ToRadians(fov);            
            this.zNear      = zNear;
            this.zFar       = zFar;
            this.aspect     = renderer.Device.Viewport.AspectRatio;

            ComputeProjectionMatrix();
            frustrum = new BoundingFrustum(ViewProjection);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// GetMouseRay
        /****************************************************************************/
        public Ray GetMouseRay(Vector2 mousePosition)
        {
            Vector3 near = new Vector3(mousePosition, 0);
            Vector3 far = new Vector3(mousePosition, 1);

            near = renderer.Device.Viewport.Unproject(near, projection, View, Matrix.Identity);
            far = renderer.Device.Viewport.Unproject(far, projection, View, Matrix.Identity);
            
            return new Ray(near, Vector3.Normalize(far - near));
        }
        /****************************************************************************/

        
        
        /****************************************************************************/
        /// GetFrustumFromRect
        /****************************************************************************/
        public BoundingFrustum GetFrustumFromRect(Rectangle source)
        {
            

            Vector2 regionCenterScreen = new Vector2(source.Center.X, source.Center.Y);

            Matrix regionProjMatrix = projection;

            regionProjMatrix.M11 /= ((float)source.Width / (float)renderer.Device.Viewport.Width);
            regionProjMatrix.M22 /= ((float)source.Height / (float)renderer.Device.Viewport.Height);

            regionProjMatrix.M31 = (regionCenterScreen.X - (renderer.Device.Viewport.Width / 2f)) / ((float)source.Width / 2f);

            regionProjMatrix.M32 = -(regionCenterScreen.Y - (renderer.Device.Viewport.Height / 2f)) / ((float)source.Height / 2f);

            return new BoundingFrustum(View * regionProjMatrix);
        
          
        }
        
        /****************************************************************************/



        /****************************************************************************/
        /// Scren Width
        /****************************************************************************/
        public int ScreenWidth
        {
            get 
            {
                return renderer.Device.Viewport.Width;
            }
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Rendered
        /****************************************************************************/
        public Renderer Renderer
        {
            get
            {
                return renderer;
            }
        }
        /****************************************************************************/



        /****************************************************************************/
        /// Scren Height
        /****************************************************************************/
        public int ScreenHeight
        {
            get 
            { 
                return renderer.Device.Viewport.Height; 
            }
        }
        /****************************************************************************/

                
        /****************************************************************************/
        /// View
        /****************************************************************************/
        public Matrix View
        {
            get
            {
                return Matrix.Invert(gameObject.World);
            }
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Inverse View
        /****************************************************************************/
        public Matrix InverseView
        {
            get
            {
                return gameObject.World;
            }
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Projection
        /****************************************************************************/
        public Matrix Projection
        {
            get
            {
                return projection;
            }
        }
        /****************************************************************************/


        /****************************************************************************/
        /// View Projection
        /****************************************************************************/
        public Matrix ViewProjection
        {
            get
            {
                return View * projection;
            }
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Inverse View Projection
        /****************************************************************************/
        public Matrix InverseViewProjection
        {
            get
            {
                return Matrix.Invert(View * projection);
            }
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Position
        /****************************************************************************/
        public Vector3 Position
        {
            get
            {
                return gameObject.World.Translation;
            }
        }
        /****************************************************************************/


        /****************************************************************************/
        /// FoV
        /****************************************************************************/
        public float FoV
        {
            get
            {
                return fov;
            }

            set
            {
                fov = value;
                ComputeProjectionMatrix();
            }
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Aspect
        /****************************************************************************/
        public float Aspect
        {
            get
            {
                return aspect;
            }

            set
            {
                aspect = value;
                ComputeProjectionMatrix();
            }
        }
        /****************************************************************************/


        /****************************************************************************/
        /// ZNear
        /****************************************************************************/
        public float ZNear
        {
            get
            {
                return zNear;
            }

            set
            {
                zNear = value;
                ComputeProjectionMatrix();
            }
        }
        /****************************************************************************/


        /****************************************************************************/
        /// ZFar
        /****************************************************************************/
        public float ZFar
        {
            get
            {
                return zFar;
            }

            set
            {
                zFar = value;
                ComputeProjectionMatrix();
            }  
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Compute Projection Matrix
        /****************************************************************************/
        private void ComputeProjectionMatrix()
        {
            projection = Matrix.CreatePerspectiveFieldOfView(FoV, aspect, ZNear, ZFar);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Rotate
        /****************************************************************************/
        private void Rotate(Vector3 vector,float angle)
        {
            quaternion = Quaternion.CreateFromAxisAngle(vector, angle);
            gameObject.World.Forward = Vector3.Transform(gameObject.World.Forward, quaternion);
            gameObject.World.Right   = Vector3.Transform(gameObject.World.Right,   quaternion);
            gameObject.World.Up      = Vector3.Transform(gameObject.World.Up,      quaternion);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Rotate X
        /****************************************************************************/
        public void RotateX(float angle)
        {
            Rotate(Vector3.Right, angle);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Rotate Y
        /****************************************************************************/
        public void RotateY(float angle)
        {            
            Rotate(Vector3.Up, angle);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Rotate Z
        /****************************************************************************/
        public void RotateZ(float angle)
        {
            Rotate(Vector3.Forward, angle); 
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Yaw
        /****************************************************************************/
        public void Yaw(float angle)
        {
            Rotate(gameObject.World.Up, angle);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Pitch
        /****************************************************************************/
        public void Pitch(float angle)
        {
            Rotate(gameObject.World.Right, angle);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Roll
        /****************************************************************************/
        public void Roll(float angle)
        {
            Rotate(gameObject.World.Forward, angle);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Move Forward
        /****************************************************************************/
        public void MoveForward(float step)
        {
            gameObject.World *= Matrix.CreateTranslation(gameObject.World.Forward * step);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Move Up
        /****************************************************************************/
        public void MoveUp(float step)
        {
            gameObject.World *= Matrix.CreateTranslation(gameObject.World.Up * step * -1);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Move Right
        /****************************************************************************/
        public void MoveRight(float step)
        {
            gameObject.World *= Matrix.CreateTranslation(gameObject.World.Right * step);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Move X
        /****************************************************************************/
        public void MoveX(float step)
        {
            gameObject.World *= Matrix.CreateTranslation(step, 0, 0);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Move Y
        /****************************************************************************/
        public void MoveY(float step)
        {
            gameObject.World *= Matrix.CreateTranslation(0, step * -1, 0);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Move Z
        /****************************************************************************/
        public void MoveZ(float step)
        {
            gameObject.World *= Matrix.CreateTranslation(0, 0, step);
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Look At (1)
        /****************************************************************************/
        public void LookAt(ref Vector3 position, ref Vector3 target, ref Vector3 up)
        {
            gameObject.World = Matrix.Invert(Matrix.CreateLookAt(position, target, up));
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Look At (2)
        /****************************************************************************/
        public void LookAt(Vector3 position,Vector3 target,Vector3 up)
        {
            gameObject.World = Matrix.Invert(Matrix.CreateLookAt(position, target, up));
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Set As Current
        /****************************************************************************/
        public void SetAsCurrent()
        {
            renderer.CurrentCamera = this;
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Release Me
        /****************************************************************************/
        public override void ReleaseMe()
        {
            if (renderer.CurrentCamera == this) renderer.CurrentCamera = null;
            base.ReleaseMe();
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Force Update
        /****************************************************************************/
        public void ForceUpdate()
        {
            ComputeProjectionMatrix();
        }
        /****************************************************************************/


        /****************************************************************************/
        /// Frustrum 
        /****************************************************************************/
        public BoundingFrustum Frustrum 
        { 
            get 
            { 
                frustrum.Matrix = ViewProjection;
                return frustrum;
            }
        }
        /****************************************************************************/

    }
    /********************************************************************************/

}
/************************************************************************************/